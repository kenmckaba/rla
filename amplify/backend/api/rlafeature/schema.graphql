enum PollMode {
  NONE
  POLL
  SHOWRESULTS
}

type Trainer @model {
  id: ID!
  name: String!
  email: String!
}

type Training
  @model
  @auth(
    rules: [{ allow: private, provider: iam }, { allow: public, provider: iam, operations: [read] }]
  ) {
  id: ID!
  trainerId: ID
  title: String!
  description: String
  trainerName: String
  trainerEmail: String
  registrationUrl: String
  maxAttendees: Int
  meetingId: String!
  moderatorPasscode: String!
  participantPasscode: String!
  scheduledTime: AWSDateTime!
  startedAt: AWSDateTime
  endedAt: AWSDateTime
  pollMode: PollMode
  currentPollId: ID
  whiteboardUrl: String
  whiteboardShared: Boolean
  attendees: [Attendee]
    @connection(name: "TrainingAttendees", keyField: "trainingId", sortField: "name")
  chatMessages: [ChatMessage] @connection(keyName: "chatMessageByTrainingId", fields: ["id"])
  polls: [Poll] @connection(name: "TrainingPolls", keyField: "trainingId")
  sharedDocs: [SharedDoc] @connection(name: "TrainingDocs", keyField: "trainingId")
}

type Attendee @model @auth(rules: [{ allow: public, provider: iam }]) {
  id: ID!
  name: String!
  email: String!
  bluejeansName: String
  handRaised: Boolean
  joinedTime: AWSDateTime
  leftTime: AWSDateTime
  currentMood: String
  posePitch: Int
  poseYaw: Int
  poseRole: Int
  trainingId: ID!
  training: Training @connection(name: "TrainingAttendees", keyField: "trainingId")
}

type SharedDoc
  @model
  @auth(
    rules: [{ allow: private, provider: iam }, { allow: public, provider: iam, operations: [read] }]
  ) {
  id: ID!
  title: String!
  type: String
  url: String!
  shared: Boolean
  trainingId: ID!
  training: Training @connection(name: "TrainingDocs", keyField: "trainingId")
}

enum PollType {
  SINGLECHOICE
  MULTICHOICE
  TEXT
}

type Poll
  @model
  @auth(
    rules: [{ allow: private, provider: iam }, { allow: public, provider: iam, operations: [read] }]
  ) {
  id: ID!
  question: String!
  type: PollType!
  answers: [String]
  trainingId: ID!
  startedAt: AWSDateTime
  stoppedAt: AWSDateTime
  training: Training @connection(name: "TrainingPolls", keyField: "trainingId")
  responses: [PollResponse] @connection(name: "pollPollResponses", keyField: "pollId")
}

type StoredPoll @model @auth(rules: [{ allow: private, provider: iam }]) {
  id: ID!
  question: String!
  type: PollType!
  answers: [String]
}

type PollResponse @model @auth(rules: [{ allow: public, provider: iam }]) {
  id: ID!
  attendeeId: ID!
  pollId: ID!
  response: [String]!
  poll: Poll @connection(name: "pollPollResponses", keyField: "pollId")
}

type ChatMessage
  @model
  @auth(rules: [{ allow: public, provider: iam }])
  @key(name: "chatMessageByTrainingId", fields: ["trainingId"]) {
  id: ID!
  content: String!
  timeSent: AWSDateTime!
  fromId: ID!
  toId: ID!
  trainingId: ID!
}

type StudentGroup @model @auth(rules: [{ allow: private, provider: iam }]) {
  id: ID!
  name: String!
  students: [Students] @connection(keyName: "byGroup", fields: ["id"])
}

type Students
  @model
  @auth(rules: [{ allow: private, provider: iam }])
  @key(name: "byGroup", fields: ["groupId"]) {
  id: ID!
  groupId: ID!
  group: StudentGroup @connection(fields: ["groupId"])
  firstName: String!
  lastName: String!
  email: String!
}

type EmailContent @model @auth(rules: [{ allow: private, provider: iam }]) {
  id: ID!
  registrationBody: String!
  registrationSubject: String!
  joinBody: String!
  joinSubject: String!
  cancelBody: String!
  cancelSubject: String!
}

type Subscription {
  onUpdateAttendeeByTrainingId(trainingId: ID!): Attendee
    @aws_subscribe(mutations: ["updateAttendee"])
  onCreateChatMessageByTrainingId(trainingId: ID!): ChatMessage
    @aws_subscribe(mutations: ["createChatMessage"])
}
